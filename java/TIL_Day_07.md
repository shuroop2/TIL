# TIL_Day_07

> 2022년 05월 27일

## 상속

### 상속 개념

- 상속의 효과
  - 부모 클래스를 재사용해서 자식 클래스를 빨리 개발 개방
  - 클래스 사이의 멤버 중복 선언 불필요
  - 클래스 간 계층적 분류 및 관리 (효율성)
  - 유지 보수 편리성 제공
- 상속 대상 제한
  - 부모 클래스의 private 접근 갖는 필드와 메소드 제외
  - 부모 클래스가 다른 패키지에 있을 경우 default 접근 갖는 필드와 메소드 제외

### 클래스 상속 (Inheritance)

- 현실 세계
  - 부모가 자식에게 물려주는 행위
  - 부모가 자식을 선택해서 물려줌
- 객체 지향 프로그램
  - 한 클래스에서 정의된 멤버 필드와 메소드를 다른 클래스가 물려 받는 것
  - 자식이 부모를 선택해서 물려받음
  - 상속 대상 : 부모 클래스의 필드와 메소드

- 상속하는 클래스
  - 슈퍼 클래스, 기반 클래스, 부모 클래스
- 상속받는 클래스
  - 서브 클래스, 파생 클래스, 자식 클래스

```java
class Parent { // 부모 클래스
	...
}
class Child extends Parent { // 상속된 자식 클래스
	...
}
```

- 자바 상속의 특징
  - 다중 상속을 지원하지 않는다
  - extends 다음에는 오직 한 개의 클래스만 사용한다
  - 상속 횟수 제한 없음
  - 계층구조의 최상위에 있는 클래스는 java.lang.Object 클래스
  - 따라서 모든 클래스는 Object 클래스로부터 상속 받는 것

### 상속에서의 생성자

- 객체(인스턴스) 초기화 목적

- 부모 클래스의 생성자 : 부모 클래스의 멤버 초기화

- 자식 클래스의 생성자 : 자식 클래스의 멤버 초기화

- 자식 클래스의 객체가 생성될 때

  - 부모 클래스의 멤버를 상속받기 때문에 부모 클래스의 생성자와 자식 클래스의 생성자 모두 실행된다

- 생성자 실행 순서

  1. 부모 클래스의 생성자가 먼저 실행
  2. 자식 클래스의 생성자 실행

- 자식 클래스와 부모 클래스의 생성자 짝 맞추기

  - 부모 클래스와 자식 클래스에 여러 개의 생성자가 있을 수 있음
  - 클래스에 아무 생성자도 정의되지 않은 경우
    - 컴파일러에 의해 자동으로 기본 생성자 호출
  - 생성자에 매개변수가 있는 경우
    - 짝을 이루는 생성자 호출
    - 짝을 이루는 생성자가 없으면 오류 발생

  - 자식 클래스와 부모 클래스의 생성자를 짝을 맞추어 선택하기 위해 super() 메소드를 사용하여 명시적인 방법으로 해당되는 생성자를 호출
  - super() : 부모 클래스의 생성자 호출

- 매개변수가 있는 생성자의 매개변수 전달 방법
  - 자식 클래스의 객체(인스턴스)가 생성되면서 자식 클래스의 생성자에게 매개변수를 전달할 때
    - 부모 클래스의 생성자에게 보낼 매개변수도 같이 전달하면 자식 클래스의 생성자가 받아서 부모 클래스의 생성자에게 필요한 만큼의 매개변수 전달

### 부모 생성자 호출 (super)

#### this

- this 레퍼런스

  > 클래스 내에서 객체 자신을 가리키는 레퍼런스

- this() 메소드

  > 한 생성자에서 다른 생성자 호출하는 메소드

#### super

- super 레퍼런스

  > 슈퍼 클래스(부모 클래스)를 가리키는 레퍼런스

- super () 메소드

  > 슈퍼 클래스의 생성자를 호출하는 메소드

  - 주의 : 생성자 안에서 맨 첫줄에 와야 함

### 접근 제한자

- 클래스, 멤버 필드, 메소드의 접근을 제어하기 위해 사용
- 클래스 내부의 정보 은폐 (정보 은닉)
- 접근 제한 대상에 따라
  - 클래스 접근 제한
  - 클래스 멤버 접근 제한 : 필드, 메소드

#### 클래스 접근 제한

> 다른 클래스에서 이 클래스를 사용할 수 있는지 허용 여부 지정하는 것

- 클래스 선언부에 표시

1. public
   - 패키지 상관없이 다른 모든 클래스에서 이 클래스에 접근하여 사용 가능
2. default
   - 접근 제한자 생략하면 default (주의 : default 라고 적지 않음)
   - 같은 패키지 내에 있는 클래스들만 접근 허용

- 클래스 멤버 접근 제한

  >  클래스의 멤버 필드와 메소드에 접근하여 사용하는 것을 허용

  1. public
     - 공용 멤버임을 표시하는 키워드 (완전 공개)
     - 패키지 상관없이 모든 클래스 외부에서 이 클래스의 멤버에 접근하여 사용하는 것을 허용
  2. private
     - 전용 멤버 (비공개)
     - 클래스 내의 멤버 메소드만 접근 가능
     - 클래스 외부에서 접근 불가
  3. protected
     - 보호 멤버 (보호된 일부 공개)
     - 허용 범위
       - 같은 패키지 내의 모든 클래스에서 접근 가능
       - 패키지 상관없이 상속받은 서브 클래스에서 접근 가능
  4. default : 접근 제한자 생략
     - 같은 패키지 내의 모든 클래스에서 접근 가능
     - 다른 패키지에 있는 클래스에서 접근 불가능

#### 생성자의 접근 제한

- 클래스 멤버 접근 제한과 동일
  - 단, 클래스가 default이면 생성자가 public이라도 같은 패키지에서만 생성자 호출 가능
- 자동으로 추가되는 기본 생성자는 클래스의 접근 제한과 동일
  - 클래스가 public이면 생성자도 public
  - 클래스가 default이면 생성자도 default

### 메소드 재정의 (Overriding)

> 부모 클래스에서 상속받은 메소드를 그대로 사용하는 것이 아니라 자식 클래스에서 재정의해서 사용하는 것

- 상속 관계에서만 발생
- 메소드에만 적용 (필드에는 적용되지 않음)
- 부모 클래스의 메소드 무시
- 메소드 재정의 효과
  - 부모 메소드를 숨기는 효과
  - 재정의된 자식 메소드 실행

#### Overriding 조건

- 부모 클래스에 선언된 메소드와 이름, 반환형, 매개변수 리스트가 완전 동일해야 함
- 부모 클래스 메소드의 접근 지정자보다 접근 범위가 좁아서는 안됨
- public > protected > default > private

#### @Override 어노테이션

- 컴파일러에게 부모 클래스의 메소드 선언부와 동일한지 검사 지시
- 정확한 메소드 재정의를 위해 붙여주면 됨

#### 부모 메소드 사용

- 자식 클래스에서 수정되기 전 부모 메소드 호출
  - super 레퍼런스 사용 `super.method1();`

### final 클래스와 final 메소드

- final
  - 최종 선언
  - 결코 수정 안됨
- final 키워드 용도
  - final 필드 : 수정 불가 필드 (상수)
  - final 클래스 : 부모로 사용 불가한 클래스 (상속 안 됨)
  - final 메소드 : 자식이 재정의할 수 없는 메소드

### 타입 변환과 다형성

#### 다형성 (Polymorphism)

> 같은 타입이지만 실행 결과가 다양한 객체를 이용 할 수 있는 성질

- 하나의 타입에 여러 개의 객체를 대입하여 다양한 기능 이용 가능
- 부모 타입에는 모든 자식 객체가 대입 가능
  - 자식 타입은 부모 타입으로 자동 타입 변환됨

#### 자동 타입 변환 (Promotion)

> 프로그램 실행 중에 자동 타입 변환이 일어나는 것

```java
부모클래스 변수 = 자식클래스타입;
```

- 바로 위의 부모가 아니더라도 상속 계층의 상위이면 자동 타입 변환 가능
- 자동 타입 변환 후에는 부모 클래스 멤버만 접근 가능
  - 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정
- 예외의 경우 : 오버라이딩
  - 메소드가 자식 클래스에 오버라이딩 되었다면 자식 클래스의 메소드가 대신 호출됨

#### 강제 타입 변환 (Casting)

> 부모 타입을 자식 타입으로 변환하는 것

```java
자식클래스 변수 = (자식클래스) 부모클래스타입;
```

- 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니고 자식 타입을 부모 타입으로 자동 변환된 후, 다시 자식 타입으로 변환할 때만 가능 (원위치 개념)
- 강제 타입 변환이 필요한 경우
  - 자식 타입이 부모 타입으로 자동 변환되면 부모 타입에 선언된 필드와 메소드만 사용 가능(오버라이딩 예외)
  - 자식 타입에 선언된 필드와 메소드를 다시 사용해야 할 경우

#### 객체 배열

> 객체를 기리키는 레퍼런스를 원소로 갖는 배열

```java
Person[] p = new Person[5]; // 레퍼런스 5개 생성
p[i] = new Person(); // 객체 생성되고 레퍼런스 배열의 각 원소가 객체를 기리킴
```

#### 객체 타입 확인 (instanceof)

- 참조 변수가 참조하고 있는 인스턴스의 실제 타입 확인

- 부모 타입이면 모두 자식 타입으로 강제 타입 변환할 수 있는 것 아님

- 부모 타입으로 변환되어 있는 상태에서만 강제 타입 변환 가능

- 아니면 ClassCastException 예외 발생

- 먼저 자식 타입인지 확인 후 강제 타입 실행해야 함

  - instanceof 연산자

  ```java
  boolean result = 좌항(객체) instanceof 우항(타입)

- - 왼쪽의 참조변수가 오른쪽 타입의 인스턴스이면 true 반환
  - true 반환되면 참조변수가 검사한 타입으로 타입 변환 가능

#### 매개변수의 다형성

- 매개변수가 클래스 타입인 경우 매개값을 다양화하기 위해 매개변수에 자식 타입 객체 대입 허용 (자동 타입 변환)
- 따라서, 해당 객체뿐 아니라 자식 객체까지도 매개값으로 사용 가능
- 매개값으로 어떤 객체가 전달되느냐에 따라 실행 결과 달라짐 -> 매개변수의 다형성
  - 자식 객체가 부모의 메소드를 재정의 했다면 내부에서 오버라이딩된 메소드를 호출함으로써 실행 결과 다양해짐

### 추상(Abstract) 클래스

#### 추상 (Abstract)

> 구체적으로 완성되지 않았다는 의미 (미완성)

#### 추상(Abstract) 클래스 

> body가 구현되지 않은 미완성 메소드를 포함하고 있다는 의미

- 구체적인 내용은 구현하지 않고 전체적인 틀만 갖춘 상황
- 상속 받는 클래스에서 용도에 맞게 구체적으로 구현해서 완성
- 추상 메소드를 포함하고 있다는 것을 제외하고는 일반 클래스와 동일 (생성자, 멤버 필드, 메소드 포함)

#### 추상 클래스 생성 방법

- 실체 클래스(객체를 만들어 사용할 수 있는 클래스)들의 공통되는 필드와 메소드를 정의
  - 공통되는 규격을 정해 놓는 것으로 상속 받는 클래스에서 반드시 이 규격대로 구현하라는 것
  - 규격 외 부분은 각 클래스 특성에 맞춰 추가

- 추상 클래스는 실체 클래스의 부모 클래스 역할
  - 주의 :  new 연산자를 사용해서 단독 객체 생성 불가

#### 추상 클래스의 용도

1. 실체 클래스의 공통된 필드와 메소드의 이름을 통일할 목적

   - 실체 클래스 설계자가 여러 사람인 경우

   - 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질 수 있음

2. 실체 클래스를 작성할 때 시간 절약

   - 실체 클래스는 추가적인 필드와 메소드만 선언 (정의)

3. 실체 클래스 설계 규격을 만들고자 할 때

   - 실체 클래스가 가져야 할 필드와 메소드를 추상 클래스에서 미리 정의

   - 실체 클래스는 추상 클래스를 무조건 상속 받아 작성

#### 추상 클래스 목적

- 서브 클래스에서 필요로 하는 대부분의 기능을 구현해 두고 서브 클래스가 상속받아 활용할 수 있도록 하되 서브 클래스에서 반드시 구현해야 하는 기능만을 추상 메소드로 선언하여 서브 클래스에서 반드시 구현하도록 하는 것

#### 추상 클래스 선언

```java
public abstract class 클래스명 {
	// 필드, 상수
	// 생성자
	// 메소드
}
```

- 클래스 선언에 abstract 키워드 사용
- new 연산자로 객체 생성하지 못하고 상속을 통해 자식 클래스만 생성 가능
  - new 연산자로 객체를 생성하지는 못하지만 자식 객체가 생성될 때 super()를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 필요 함

#### 추상 메소드

> 선언은 되어 있으나 body가 정의되어 있지 않은 메소드

```java
[public | protected] abstract 리턴타입 메소드명(매개변수, ...);
```

##### 추상 메소드와 오버라이딩

- 메소드 이름 동일하지만 실행 내용이 실체 클래스마다 다른 경우 추상 메소드로 선언
- ex) : 동물은 소리를 낸다. 그러나 실체 동물들의 소리는 제각기 다르다.
- 구현 방법
  - 추상 클래스에는 메소드의 선언부만 작성(추상 메소드) : 메소드의 body 없음
  - 실체 클래스에서 메소드의 실행 내용 작성 (오버라이딩)