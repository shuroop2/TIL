# TIL_Day_09

> 2022년 05월 28일

## 중첩 클래스와 중첩 인터페이스

### 중첩 클래스 (Nested Class)

> 클래스 내부에 선언한 클래스

```java
class ClassName {
	class NestedClass {
	}
}
```

- 클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는 것이 좋으나 특정 클래스와 관계를 맺을 경우에는 관계 클래스를 해당 클래스 내부에 선언하는 것이 좋음
- 클래스 내부에 선언되는 위치에 따라 2가지로 분류
  - 멤버 클래스
    - 클래스의 멤버로서 선언되는 중첩 클래스
    - 클래스나 객체가 사용 중이면 언제든지 재사용 가능
  - 로컬 클래스
    - 메소드 내에서만 선언되는 중첩 클래스
    - 메소드 실행 시에만 사용
    - 메소드가 실행 종료되면 없어짐
- 중첩 클래스도 클래스이기 때문에 컴파일하면 바이트 코드 파일(.class)이 별도로 생성

#### 중첩 클래스 분류

| 선언 위치에 따른 분류 | 선언 위치                                                    | 설명                                                |
| --------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| 인스턴스 멤버 클래스  | class A {<br>    class B {...}<br>}                          | A 객체를 생성해야만 사용할 수 있는 B 중첩 클래스    |
| 정적 멤버 클래스      | class A {<br>    static class B {...}<br>}                   | A 클래스로 바로 접근할 수 있는 B 중첩 클래스        |
| 로컬 클래스           | class A {<br>    void method() {<br>        class B {...}<br>    }<br>} | method()가 실행할 때만 사용할 수 있는 B 중첩 클래스 |

1. 인스턴스 멤버 클래스
   - static 키워드 없이 선언된 클래스
   - 인스턴스 필드와 메소드만 선언 가능
   - static 필드와 메소드는 선언할 수 없음
   - A 클래스의 객체를 생성해야만 사용할 수 있음
2. 정적 멤버 클래스
   - static 키워드로 선언된 클래스, 모든 종류의 필드, 메소드 선언 가능
   - A 클래스 외부에서 정적 멤버 클래스 객체를 생성하기 위해서는 A 객체 생성 필요 없음
3. 로컬 클래스
   - 메소드 내에서 선언된 클래스
   - 메소드 내에서만 사용하기 때문에 접근 제한 및 static 필요 없음 (안 붙임)
   - 로컬 클래스 내부에는 인스턴스 필드와 메소드만 선언이 가능하고 static 필드와 메소드는 선언할 수 없음

#### 중첩 클래스 사용 이점

- 두 클래스 멤버들을 서로 쉽게 접근 가능
- 코드의 복잡성 줄일 수 있음
  - 관계 클래스는 중첩 클래스로, 불필요한 관계 클래스는 외부에서 감출 수 있기 때문

### 중첩 클래스의 접근 제한

1. 바깥 필드와 메소드에서 사용 제한
   - 인스턴스 멤버 클래스는 바깥 클래스의 인스턴스 필드의 초기값이나 인스턴스 메소드에서 객체를 생성 가능
   - 정적 필드의 초기값이나 정적 메소드에서는 객체 생성 불가
   - 정적 멤버 클래스는 모든 필드의 초기값이나 모든 메소드에서 객체 생성 가능
2. 멤버 클래스에서 사용 제한
   - 인스턴스 멤버 클래스 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근 가능
   - 정적 멤버 클래스 안에서는 바깥 클래스의 정적 필드와 메소드에만 접근 가능하고, 인스턴스 필드와 메소드에는 접근 불가
3. 로컬 클래스에서 사용 제한
   - 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용 가능
   - 문제는 메소드의 매개 변수나 로컬 변수를 사용할 때
     - 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리 영역에 존재하기 때문에 계속 사용될 수 있지만 메소드 실행 끝나면 매개 변수나 로컬 변수는 스택 메모리에서 사라지기 때문에 로컬 객체에서 사용할 경우 문제 발생
     - 문제 해결법
       - 매개 변수나 로컬 변수를 final로 선언해서 수정하지 못하게 함
       - 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용하는데 매개 변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제가 발생하니까 변경되지 않도록 final로 선언
       - 즉, 로컬 클래스에서 사용 가능한 것은 final로 선언된 매개 변수와 로컬 변수 뿐 (로컬 클래스에서 사용하고자 하는 매개 변수와 로컬 변수에는 final을 붙임)

#### final 키워드

- 자바 7 이전까지는 final 키워드가 없으면 컴파일 오류
- 자바 8 부터는 final 키워드 없어도 오류 없음
  - final 키워드 안 붙여도 final 특성 가짐

#### 중첩 클래스에서 바깥 클래스 참조 얻기

- this 사용

  ```java
  바깥클래스.this.필드
  바깥클래스.this.메소드()
  ```

##### this

- 클래스 내부에서 객체 자신 참조
- 중첩 클래스에서 중첩 클래스의 객체 참조 (바깥 클래스의 객체 참조 아님)
- `this.필드`, `this.메소드()`로 호출하면 중첩 클래스의 필드와 메소드 사용 가능

### 중첩 인터페이스

> 클래스 내부에 클래스의 멤버로 선언된 인터페이스

```java
class ClassName {
	interface NestedInterfaceName {
	}
}
```

- 인터페이스를 클래스 내부에 선언하는 이유
  - 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해 (주로 클래스 외부에서는 사용하지 않고 클래스에서만 사용하는 경우)
  - 특히 UI 프로그래밍에서 이벤트 처리 목적으로 많이 활용

#### 중첩 인터페이스 선언

- ex)

  ```java
  public class Button {
      OnClickListener listener;	// 인터페이스 타입으로 필드 선언
      // Setter 메소드로 구현 객체를 받아 필드에 대입
      void setOnClickListener(OnClickListener listener) { 
          this.listener = listener;
      }
      // 버튼 이벤트가 발생했을 때 touch() 메소드 호출
      void touch() {
          listener.onClick(); // 인터페이스를 통해 구현 객체의 메소드 호출
      }
      // 중첩 인터페이스
      interface OnClickListener {
          void onClick
      }
  }
  ```

  - Button을 클릭했을 때 Button 클래스 내부에 선언된 중첩 인터페이스로 이벤트 처리
  - Button 클래스에서만 사용하는 인터페이스이기 때문에 중첩 인터페이스로 선언

### 익명 객체 생성

#### 익명 자식 객체 생성

1. 일반적인 객체 생성

   - 부모 클래스 상속해서 자식 클래스 선언하고
   - new 연산자를 이용해서 객체 생성한 후
   - 필드나 로컬 타입에 대입

2. 익명 자식 객체 생성

   - 자식 클래스가 재사용되지 않고 해당 필드와 변수의 초기값으로만 사용할 경우라면

   - 익명 자식 객체를 생성해서 초기값으로 대입하는 것이 좋은 방법

   - 일반 클래스와 차이점은 생성자 생성 불가

   - 익명 자식 객체 생성 방법

     ```java
     부모클래스 [필드|변수] = new 부모클래스(매개값, ...) {
         // 필드
         // 메소드
         // 메소드 재정의
     };
     ```

     1. 익명 자식 객체 생성해서 클래스의 필드에 대입
     2. 메소드 내에서 로컬 변수를 선언할 때 초기값으로 익명 자식 객체 생성해서 대입
     3. 메소드의 매개 변수가 부모 타입일 경우 메소드 호출 코드에서 익명 자식 객체 생성해서 매개값으로 대입

##### 익명 자식 객체에 새롭게 정의된 필드와 메소드

- 익명 자식 객체 내부에서만 사용
- 외부에서는 익명 객체의 필드와 메소드에 접근할 수 없음
  - 이유 : 익명 자식 객체는 부모 타입 변수에 대입되므로 부모 타입에 선언된 것만 사용 가능하기 때문

##### 익명 자식 객체의 필드와 메소드 접근 제한

- 익명 자식 객체 내부에서만 사용
- 외부에서는 익명 객체의 필드와 메소드에 접근할 수 없음
- 익명 자식 객체는 이름이 없으므로 자신의 타입의 클래스를 만들지 못함
- 그래서 무조건 부모 타입의 변수에 대입해야함 (자동 타입 변환되어 대입)
  - 따라서 부모 타입의 필드로는 부모 타입으로 정의된 것만 접근 가능 (재정의된 메소드)
  - 익명 객체의 필드와 메소드를 사용하려면 재정의된 메소드 내에서 사용하면 됨

#### 익명 구현 객체 생성

- 인터페이스 타입으로 필드나 변수를 선언하고 구현 객체를 초기값으로 대입

- 구현 클래스가 재사용되지 않고, 해당 필드와 변수의 초기값으로 사용하는 경우에는 익명 구현 객체를 초기값으로 대입하는 것이 좋음

- 익명 구현 객체 생성 방법

  ```java
  인터페이스 [필드|변수] = new 인터페이스() {
      // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
      // 필드
      // 메소드
  };
  ```

  - 중괄호 { }
    - 인터페이스를 구현해서 클래스 생성
    - 인터페이스에 선언된 모든 추상 메소드의 실체 메소드 작성
    - 추가적으로 필드와 메소드 선언 가능하지만, 메소드 내에서만 사용 가능하고 외부에서 사용 불가

  1. 필드 선언 시 초기값으로 익명 구현 객체 생성해서 대입
  2. 메소드 내에서 로컬 변수 선언할 때 초기값으로 익명 구현 객체 대입해서 생성
  3. 메소드의 매개 변수가 인터페이스 타입일 경우 메소드 호출 코드에서 익명 구현 객체를 생성해서 매개값으로 대입