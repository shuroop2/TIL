# TIL_Day_94

> 2023년 1월 4일

## JPA(Java Persistence API)

> 자바 퍼시스턴스 API 또는 자바 지속성 API는 자바 진영에서 ORM(Object Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음이다. 그 말은 즉, 실제적으로 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크이다. JPA를 구현한 대표적인 오픈 소스로는 Hibernate가 있다.

![](https://ultrakain.gitbooks.io/jpa/content/chapter1/images/JPA.png)

### ORM(Object Relational Mapping)

- 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다.
  - 객체 지향 프로그래밍은 **클래스**를 사용하고, 관계형 데이터베이스는 **테이블**을 사용한다.
  - 객체 모델과 관계형 모델 간에 불일치가 존재한다.
  - ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.
- 데이터베이스 데이터 <- 매핑 -> Object 필드
  - 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.
- Persistant API라고도 할 수 있다.
  - Ex) JPA, Hibernate 등

#### ORM의 장점

- 객체 지향적인 코드로 인해 더 직관적이고 **비즈니스 로직에 더 집중**할 수 있게 도와준다.
  - ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는 데 집중할 수 있도록 도와준다.
  - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
  - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
  - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
- **재사용 및 유지보수**의 편리성이 증가한다.
  - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.
  - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
  - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
- **DBMS에 대한 종속성이 줄어든다.**
  - 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 Java의 객체지향 모델 사이 간격을 좁힐 수 있다.
  - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
  - 종속적이지 않다는것은 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다.
  - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
  - 또한 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

#### ORM의 단점

- 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
  - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
  - 프로젝트의 복잡성이 커질 경우 난이도 또한 올라갈 수 있다.
  - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
  - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는 등 별도의 튜닝이 필요한 경우가 있다.
  - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유 기능을 이용하면 이식성이 저하된다.)
- 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
  - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

### JPA(Java Persistence API)

- Java 진영에서 ORM 기술 표준으로 사용하는 인터페이스 모음
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
- 인터페이스이기 때문에 Hibernate, OpenJPA 등이 JPA를 구현함

![](https://ultrakain.gitbooks.io/jpa/content/chapter1/images/JPA_interface.png)

#### 객체를 저장하는 코드

```java
jpa.persist(member);	// 저장
```

![](https://ultrakain.gitbooks.io/jpa/content/chapter1/images/JPA_save.png)

#### 객체를 조회하는 코드

```java
Member member = jpa.find(memberId);	// 조회
```

![](https://ultrakain.gitbooks.io/jpa/content/chapter1/images/JPA_search.png)

#### JPA 사용 이유

##### 생산성

- JPA를 자바 컬렉션에 **객체를 저장하듯** JPA에게 저장할 객체를 전달.
- INSERT SQL을 작성하고 JDBC API 사용하는 **지루하고 반복적인 일을 JPA가 대신** 처리해준다.
- CREATE TABLE같은 **DDL문 자동 생성**
- 데이터베이스 설계 중심의 **패러다임을 객체 설계 중심**으로 역전

```java
jpa.persist(member);	// 저장
Member member = jpa.find(memberId);	// 조회
```

##### 유지보수

- 엔티티에 필드 추가시 등록, 수정, 조회 관련 코드 모두 변경
- JPA를 사용하면 이런 과정을 JPA가 대신 처리
- 개발자가 작성해야 할 SQL과 JDBC API 코드를 JPA가 대신 처리해줌으로 유지보수해야 하는 코드 수가 줄어든다.

##### 패러다임 불일치 해결

- 상속, 연관관계, 객체 그래프 탐색, 비교하기 같은 패러다임 불일치 해결

##### 성능

- 다양한 성능 최적화 기회 제공
- 어플리케이션과 데이터베이스 사이에 존재함으로 여러 최적화 시도 가능

##### 데이터 접근 추상화와 벤더 독립성

- 데이터베이스 기술에 종속되지 않도록 한다.
- 데이타베이스를 변경하면 JPA에게 다른 데이터베이스를 사용한다고 알려주면 됨.

![](https://ultrakain.gitbooks.io/jpa/content/chapter1/images/JPA_vendor_indifendent.png)

##### 표준

- 자바 진영의 ORM 기술 표준