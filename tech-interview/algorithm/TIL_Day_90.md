# TIL_Day_90

> 2022년 12월 08일

## 비트마스크 알고리즘

> 비트마스크는 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진수 표현을 자료 구조로 쓰는 기법을 말한다. 이진수는 0 또는 1을 이용하므로 하나의 비트(bit)가 표현할 수 있는 경우는 두 가지이다.

### 비트마스크의 장점

1. 수행 시간이 빠르다.
   - 비트마스크 연산은 bit 연산이기 때문에 O(1)에 구현되는 것이 많다. 따라서 다른 자료구조를 이용하는 것보다 훨씬 빠르게 동작하게 된다. 다만, 비트마스크를 이용하는 경우에는 비트의 개수만큼 원소를 다룰 수 있기 때문에 연산 횟수가 적은 경우에는 속도에 큰 차이가 없지만, 연산 횟수가 늘어날수록 차이가 매우 커지게 된다.
2. 코드가 짧다.
   - 다양한 집합 연산들을 비트연산자 한 줄로 작성할 수 있기 때문에 반복문, 조건문 등을 이용한 코드보다 훨씬 간결한 코드를 작성할 수 있다.
3. 메모리 사용량이 더 적다.
   - 간단한 예시로, bit가 10 개인 경우에는 각 bit당 두 가지 경우를 가지기 때문에 210210 가지의 경우를 10bit 이진수 하나로 표현이 가능하다. 
   - 이처럼 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이며, 더 많은 데이터를 미리 계산해서 저장해 둘 수 있는 장점이 있다. (DP에 매우 유용하다)

### 비트 연산자

비트마스크를 이용하기 위해서, 정수 변수를 비트 별로 조작할 수 있는 비트연산자를 사용한다. 두 정수 변수 또는 하나의 정수 변수를 이용하여 새로운 값을 만들어 내는 것이 목적이다.

1. AND 연산 (&)
   - 두 정수 변수 a와 b를 통해서 c를 생성한다고 가정하면, a와 b를 한 bit씩 비교하면서 해당 비트가 **둘 다 켜져 있는 경우**에만 c의 해당 비트를 켠다.
2. OR 연산 (|)
   - AND 연산과 같은 방식으로, 해당 비트가 **둘 중 하나라도 켜져 있는 경우**에 c의 해당 키트를 켠다.
3. XOR 연산 (^)
   - 마찬가지로 같은 방식이며, 해당 비트가 **둘 중 하나만 켜져 있는 경우**에 c의 해당 비트를 켠다.
4. NOT 연산 (~)
   - 정수 하나를 입력 받아서 **켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과**를 반환한다.
5. 시프트(Shift) 연산 (<<, >>, >>>)
   - 시프트 연산자는 정수 a의 **비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다.** 움직이고 나서 빈자리는 0으로 채워지거나, 정수 a의 최상위 부호 비트와 같은 값으로 채워지게 된다. 예를 들어 13(1101)을 오른쪽으로 1bit 움직인다고 하면, 6(0110)이 되는 것이다.

- 주의할 점
  1. 비트 연산자들의 우선순위는 비교 연산자보다 낮다.
  2. 오버플로우 발생

