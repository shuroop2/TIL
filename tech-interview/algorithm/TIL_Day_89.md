# TIL_Day_89

> 2022년 12월 07일

## 플로이드-워셜(Floyd-Warshall)

> 변의 가중치가 음이거나 양인 (음수 사이클은 없는) 가중 그래프에서 최단 경로들을 찾는 알고리즘이다. 알고리즘을 한 번 수행하면 모든 꼭짓점 쌍 간의 최단 경로의 길이(가중치의 합)을 찾는다. 알고리즘 자체는 경로를 반환하지는 않지만, 알고리즘을 약간만 변형시키면 경로를 찾을 수 있다.

- 다익스트라는 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘(S.S.S.P - Single Source Shortest Path) 이었다면, 플로이드-워셜 알고리즘은 한 번 실행하여 **모든 노드 간 최단 경로**를 구할 수 있다.

### 플로이드-워셜의 과정

모든 노드 간의 최단 거리를 구해야 하므로 2차원 인접 행렬을 구성한다. 알고리즘은 여러 라운드로 구성된다. 라운드마다 각 경로에서 새로운 중간 노드로 사용할 수 있는 노드를 선택하고, **더 짧은 길이를 선택하여 줄이는 과정을 반복**한다.

![](https://i.imgur.com/31QRL4P.png)

초기 그래프를 인접 행렬로 나타내면 다음과 같다. INF는 해당 노드에서 특정 노드까지 가는 길이 없다는 뜻이다.

| **0**   | **5**   | **INF** | **9**   | **1**   |
| ------- | ------- | ------- | ------- | ------- |
| **5**   | **0**   | **2**   | **INF** | **INF** |
| **INF** | **2**   | **0**   | **7**   | **INF** |
| **9**   | **INF** | **7**   | **0**   | **2**   |
| **1**   | **INF** | **INF** | **2**   | **0**   |

------

- ROUND 1 : 1번 노드를 새로운 중간 노드로 설정

이 그래프는 1번부터 5번 노드까지 존재하므로 알고리즘은 총 5라운드의 과정을 거친다. 즉, 모든 노드들은 중간 노드로 선정하는 과정을 각 라운드마다 거친다. 예를 들어 2라운드는 2번 노드가 중간 노드이며, 3라운드는 3번 노드가 중간 노드가 될 것이다.

2번에서 4번으로 가는 길은 원래 없었으나, **1번 노드를 중간 노드로 선정할 경우 2-1-4(길이 5+9=14)로 갈 수 있게 된다.** (업데이트 된 길이는 ⭐로 표시)

| **0**   | **5**   | **INF** | **9**   | **1**   |
| ------- | ------- | ------- | ------- | ------- |
| **5**   | **0**   | **2**   | **14⭐** | **6⭐**  |
| **INF** | **2**   | **0**   | **7**   | **INF** |
| **9**   | **14⭐** | **7**   | **0**   | **2**   |
| **1**   | **6⭐**  | **INF** | **2**   | **0**   |

-----

- ROUND 2 : 2번 노드를 새로운 중간 노드로 설정

1번 - 3번 노드를 잇는 경로, 3번 - 5번 노드를 잇는 경로가 새로 생기게 된다.

| **0**  | **5**  | **7⭐** | **9**  | **1**  |
| ------ | ------ | ------ | ------ | ------ |
| **5**  | **0**  | **2**  | **14** | **6**  |
| **7⭐** | **2**  | **0**  | **7**  | **8⭐** |
| **9**  | **14** | **7**  | **0**  | **2**  |
| **1**  | **6**  | **8⭐** | **2**  | **0**  |

-----

이런 과정으로 5번 노드를 중간 노드로 선정하는 라운드까지 모두 거치면 행렬에는 모든 노드 간 최단 거리가 들어가게 된다.

### JAVA로 구현

플로이드-워셜 알고리즘은 시간 복잡도가 O(n^3)으로, 그래프의 크기가 작아 세제곱 시간 알고리즘을 적용해도 문제가 풀릴 때만 사용할 수 있다.

```java
import java.io.IOException;
import java.util.Arrays;

public class Floyd_Warshall {
    static final int INF = 99999999;
    
    public static void main(String[] args) throws IOException {
        // 정점의 수 입력
        int N = 4;

        // 인접 행렬 입력
        int[][] D = {{0, 2, 0, 15},
                     {0, 0, 10, 4},
                     {3, 0, 0, 0},
                     {0, 0, 7, 0}};

        // 갈 수 없는 경로 확인
        for(int i=0; i<N; i++) {
            for(int j=0; j<N; j++) {
                if(i == j)
                    continue;
                if(D[i][j] == 0)
                    D[i][j] = INF;
            }
        }

        // 입력 출력
        System.out.println("=============입력=============");
        for(int[] row : D)
            System.out.println(Arrays.toString(row));

        // 플로이드-워셜
        for(int k=0; k<N; k++) {  // 경유 노드 확인
            for(int i=0; i<N; i++) {  // 출발지
                if(i == k)
                    continue;  // 출발지와 경유지가 같으면 다음 탐색
                for(int j=0; j<N; j++) {  // 도착지
                    if (j == i || j == k)
                        continue;  // 출발지와 도착지가 같거나 도착지가 경유지이면 다음 탐색
                    D[i][j] = Math.min(D[i][k] + D[k][j], D[i][j]);  // 경유하거나 직접가거나 더 짧은 경로로 대체
                }
            }
        }

        // 결과 출력
        System.out.println("=============결과=============");
        for(int[] row : D)
            System.out.println(Arrays.toString(row));
    }
}