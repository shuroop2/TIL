# TIL_Day_72

> 2022년 10월 25일

## 알고리즘의 정의

> 어떤 문제를 컴퓨터를 사용해서 해결하기 위한 절차나 방법

### 알고리즘의 조건

- 입력 : 알고리즘은 0 또는 그 이상의 외부에서 제공된 자료가 존재한다.
- 출력 : 알고리즘은 최소 1개 이상의 결과가 있어야 한다.
- 명확성 : 알고리즘의 각 단계는 애매함 없는 명확한 과정으로 구성되어야 한다.
- 유한성 : 알고리즘은 유한한 수의 단계를 수행한 후 문제가 해결되고 종료되어야 한다.
- 효율성 : 알고리즘의 모든 연산은 명백하게 실행할 수 있음을 검증할 수 있어야 한다.

#### 알고리즘의 효율성

> 컴퓨터를 사용해 주어진 조건에 맞게 효율적으로 문제를 해결하는 절차와 방법을 우선한다.

- 코드 1 : 출력할 수 만큼 printf() 사용

  ```c
  #include<stdio.h>
  int main() {
  	printf("Hello World!\n");
     	printf("Hello World!\n");
      printf("Hello World!\n");
  }
  ```

- 코드 2: 반복문 사용

  ```c
  #include<stdio.h>
  int main() {
  	for (int i = 0; i < 3; i++) {
  		printf("Hello World!\n");
  	}
  }
  ```

- 결과

  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOR3bk%2FbtqB1cqASFo%2FWK3r39fnYXUv5ohK7Kpq61%2Fimg.png)

- 코드 1의 경우 : 3개의 printf() 함수를 차례대로 출력한다. 각 printf() 함수에 있는 문자열 모두 모니터를 화면에 출력하는 기능만 있으므로, printf() 함수 안에서 사용하는 연산과 메모리를 제외하고는 메모리에 할당해야 할 변수나 실행해야 할 연산이 없다. 반복해서 출력해야 할 문자열이 늘어날수록 printf() 함수를 추가로 작성해야 한다.

- 코드 2의 경우 : 공통으로 출력되는 문자열이 있다는 점을 확인 한 후 for문을 사용해 이를 반복해서 출력한다. 코드 1과 비교했을때 코드 행이 적고, 지역변수 i와 printf() 함수 3개 안에 있는 문자열을 메모리에 할당한다. 출력해야 할 문자열이 늘어나도 for문의 종결 조건만 바꿔주면 된다. 따라서 코드가 간결하다.

##### 시간의 효율성

> 시간의 효율성은 모든 알고리즘에서 가장 중요하게 생각하는 요소이다. 컴퓨터에서 실행되는 프로그램이라면 주어진 조건에 맞춰 문제를 해결하는데 무한대의 시간을 사용할 수 없다.

- 코드 1: 순서대로 비교

  ```c
  #include<stdio.h>
  int main() {
      int i, input;
      int data[1000];
      
      for(i=0; i<1000; i++) {
          data[i] = i;
      }
      printf("찾을 값을 입력하시오 : ");
      scanf_s("%d", &input);
      
      for(i=0; i<1000; i++) {
          if(input == data[i]) {
              printf("찾으려는 값이 배열 data의 %d번째 있습니다.\n", i);
              break;
          }
      }
      return 0;
  }

- 코드 2: 중간값을 이용해서 비교

  ```c
  #include<stdio.h>
  int main() {
      int i, input;
      int data[1000];
      int min = 0, max = 1000;
      int count = 0;
      
      for(i=0; i<1000; i++) {
          data[i] = i;
      }
      printf("찾을 값을 입력하시오 : ");
      scanf_s("%d", &input);
      
      i = (max + min) / 2;
      while(true) {
          if(input == data[i]) {
              printf("찾으려는 값이 배열 data의 %d번째 있습니다.(카운트 : %d)\n", i, count+1);
              break;
          } else if (input > data[i]) {
              min = data[i];
          } else {
              max = data[i];
          }
          
          i = (max + min) / 2;
          count++;
      }
      return 0;
  }
  ```

- 코드 1의 경우 : 0부터 999까지 데이터를 차례로 검색한다. 따라서 0의 경우 한 번에 원하는 경우를 찾을 수 있지만 원하는 데이터가 맨 뒤에(999인 경우) 무려 1000번 비교해야하는 단점이 있다.

- 코드 2의 경우 : 사용자가 입력한 값과 배열의 중간값을 비교해서 배열을 이둥분하여 배열의 중간값보다 작으면 앞부분의 중간값과 비교하고, 배열의 중간값보다 크면 뒷부분과 비교한다. 이 프로그램의 경우 최악의 경우라 하더라도 10번 이내로 원하는 데이터를 찾을 수 있다.

##### 공간의 효율성

> 두 번째로 고려해야 할 요소는 공간의 효율성이다. 공간의 효율성은 컴퓨터에서 사용하는 메모리와 관계가 있는데, 아무리 물리적인 메모리 가격이 저렴해졌다고 하더라도 무한대의 메모리를 사용할 수는 없다. 따라서 메모리를 효율적으로 관리하고 사용하는 것이 중요하다.

```c
#include<stdio.h>
void main() {
    int i;
    int data[1000];
    
    for(i=0; i<10; i++) {
        data[i] = i;
    }
}
```

- 위의 코드의 경우 int 자료형 배열 data를 선언하고 안에 0부터 9까지의 정수값을 저장하는 코드이다. 그러나 고작 10개의 자료를 저장하기 위해 int 자료형 배열 1000개 분량의 메모리 공간을 선언했기 때문에 990개의 불필요한 메모리 공간이 생기게 되었다. 이 같은 경우 굳이 int 자료형 배열 data를 1000개나 잡을 필요가 없다.

```c
#include<stdio.h>
int add(void);
int subtract(void);

// 지역변수로 사용할 변수를 전역변수로 선언했다.
int a, b;
int ret;

int add(void) {
    return a + b; // 전역변수를 사용하여 메모리가 낭비된다.
}

int subtract(void) {
    return a - b;
}

int main() {
    a = 100;
    b = 90;
    
    ret = add();
    printf("%d\n", ret);
    
    ret = subtract();
    printf("%d\n", ret);
}
```

- 위의 코드의 경우 함수의 매개변수를 비롯한 코드 안에서 사용하는 변수를 전역변수로 사용하고 있다. 전역변수는 지역변수와는 달리 프로그램의 실행 시점부터 메모리 공간을 계속 유지하므로 상당히 비효율적이다. 부득이한 경우에는 전역변수를 사용해야겠지만 되도록 전역변수의 사용을 줄여야 한다.

##### 코드의 효율성

- 코드의 효율성은 프로그래머 입장에서 보는 코드의 효율성과 컴퓨터 입장에서 보는 코드의 효율성이 있다.
  - 프로그래머 입장에서의 코드 효율성 : 가독성이 좋은 코드, 시간이 지난 후 다시 해당 코드를 수정하더라도 쉽게 수정할 수 있어야 한다. 또한 다른 프로그래머가 해당 코드를 볼 때도 되도록 쉽게 이해할 수 있어야 한다.
  - 컴퓨터 입장에서의 코드 효율성 : 컴파일러와 하드웨어에 좀 더 최적화 된 코드를 의미한다. 프로그래머 입장에서 효율적인 알고리즘을 만든다고 하더라도 컴퓨터 입장에서는 그다지 좋은 코드가 아닐 수도 있다.